<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Hexo"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        

<article id="post-leetcode-mark" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/10/06/leetcode-mark/">leetcode_mark</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/10/06/leetcode-mark/" class="article-date">
  <time datetime="2019-10-06T06:23:53.000Z" itemprop="datePublished">2019-10-06</time>
</a>
        
      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h1 id="Leetcode笔记"><a href="#Leetcode笔记" class="headerlink" title="Leetcode笔记"></a>Leetcode笔记</h1><h2 id="数组部分"><a href="#数组部分" class="headerlink" title="数组部分"></a>数组部分</h2><h3 id="两数之和-返回和为target的两个元素的下标"><a href="#两数之和-返回和为target的两个元素的下标" class="headerlink" title="两数之和   返回和为target的两个元素的下标"></a>两数之和   返回和为target的两个元素的下标</h3><h4 id="方法一：暴力法-时间复杂度o-n2-没有多余开辟的空间"><a href="#方法一：暴力法-时间复杂度o-n2-没有多余开辟的空间" class="headerlink" title="方法一：暴力法  时间复杂度o(n2)  没有多余开辟的空间"></a>方法一：暴力法  时间复杂度o(n2)  没有多余开辟的空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    return new int[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：hash-map"><a href="#方法二：hash-map" class="headerlink" title="方法二：hash map"></a>方法二：hash map</h4><ul>
<li>利用hash以空间换取时间的思想 时间复杂度为o(n) 但是要考虑如果hash冲突的问题  </li>
<li>可以从这个角度考虑 不要先将所有的值都加入hash map中去，每个元素加进去的必要条件是当前这个元素和hash map中的元素没有sum为target的值，如果有的话直接返回（即如果是两个下标不同，但value相同的元素需要采取此办法）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int complement = target - nums[i];</span><br><span class="line">            if (map.containsKey(complement)) &#123;</span><br><span class="line">                return new int[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7 整数反转"></a>7 整数反转</h3><h4 id="带有溢出的反转-考虑int溢出的问题-注意整数的表示"><a href="#带有溢出的反转-考虑int溢出的问题-注意整数的表示" class="headerlink" title="带有溢出的反转 考虑int溢出的问题 注意整数的表示"></a>带有溢出的反转 考虑int溢出的问题 注意整数的表示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        long res = 0;</span><br><span class="line">        while(x!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            int pop = x%10;</span><br><span class="line">            res =res*10 + pop;</span><br><span class="line">            if(res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE)</span><br><span class="line">                return 0;</span><br><span class="line">            x/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h3><h4 id="此题主要问题在于如何处理相加的问题，同时要生成新的链表，考虑小学学过的加法，设置进位标志carry-长度不一的只需在高位补0即可，最后一定要注意最后一位的carry是否会有进位。-此外，如果不设置头结点（无用，只是用来标记头部），则首节点设置会非常麻烦。"><a href="#此题主要问题在于如何处理相加的问题，同时要生成新的链表，考虑小学学过的加法，设置进位标志carry-长度不一的只需在高位补0即可，最后一定要注意最后一位的carry是否会有进位。-此外，如果不设置头结点（无用，只是用来标记头部），则首节点设置会非常麻烦。" class="headerlink" title="此题主要问题在于如何处理相加的问题，同时要生成新的链表，考虑小学学过的加法，设置进位标志carry,长度不一的只需在高位补0即可，最后一定要注意最后一位的carry是否会有进位。  此外，如果不设置头结点（无用，只是用来标记头部），则首节点设置会非常麻烦。"></a>此题主要问题在于如何处理相加的问题，同时要生成新的链表，考虑小学学过的加法，设置进位标志<code>carry</code>,长度不一的只需在高位补0即可，最后一定要注意最后一位的carry是否会有进位。  此外，如果不设置头结点（无用，只是用来标记头部），则首节点设置会非常麻烦。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    ListNode res = new ListNode(0);</span><br><span class="line">    ListNode p = l1, q =l2, curr = res;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        while(p!=null||q!=null)&#123;</span><br><span class="line">          int x = (p!=null)?p.val: 0;</span><br><span class="line">          int y = (q!=null)?q.val: 0;</span><br><span class="line">          int temp = x+y+carry;</span><br><span class="line">          carry = temp/10; </span><br><span class="line">          curr.next = new ListNode(temp%10);</span><br><span class="line">            //向后遍历</span><br><span class="line">            curr = curr.next;</span><br><span class="line">          if(p!=null) p = p.next;</span><br><span class="line">          if(q!=null) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry==1)</span><br><span class="line">            curr.next = new ListNode(1);</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-最长不重复子串"><a href="#3-最长不重复子串" class="headerlink" title="3 最长不重复子串"></a>3 最长不重复子串</h3><h4 id="way2-利用滑动窗口，利用set集合保存字符，首先寻找从第一个元素开始的最长的子串，找到后记下来更新为max-之后去掉此字符，从第二个开始，但注意此时不需要重新开始设置set集合，此时j指针指向的位置肯定和前面某一个字符重复，虽然无法确定，但可以继续执行，若和去掉的i重复，则j可以依次向后，若不是，i会继续加大，找到重复的那个元素，从而继续加大j，直到j到达末尾，则max就是最大的子串长度，此方法只需要o-2n）的复杂度。"><a href="#way2-利用滑动窗口，利用set集合保存字符，首先寻找从第一个元素开始的最长的子串，找到后记下来更新为max-之后去掉此字符，从第二个开始，但注意此时不需要重新开始设置set集合，此时j指针指向的位置肯定和前面某一个字符重复，虽然无法确定，但可以继续执行，若和去掉的i重复，则j可以依次向后，若不是，i会继续加大，找到重复的那个元素，从而继续加大j，直到j到达末尾，则max就是最大的子串长度，此方法只需要o-2n）的复杂度。" class="headerlink" title="way2:利用滑动窗口，利用set集合保存字符，首先寻找从第一个元素开始的最长的子串，找到后记下来更新为max,之后去掉此字符，从第二个开始，但注意此时不需要重新开始设置set集合，此时j指针指向的位置肯定和前面某一个字符重复，虽然无法确定，但可以继续执行，若和去掉的i重复，则j可以依次向后，若不是，i会继续加大，找到重复的那个元素，从而继续加大j，直到j到达末尾，则max就是最大的子串长度，此方法只需要o(2n）的复杂度。"></a>way2:利用滑动窗口，利用set集合保存字符，首先寻找从第一个元素开始的最长的子串，找到后记下来更新为max,之后去掉此字符，从第二个开始，但注意此时不需要重新开始设置set集合，此时j指针指向的位置肯定和前面某一个字符重复，虽然无法确定，但可以继续执行，若和去掉的i重复，则j可以依次向后，若不是，i会继续加大，找到重复的那个元素，从而继续加大j，直到j到达末尾，则max就是最大的子串长度，此方法只需要o(2n）的复杂度。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if(s.length()==0) return 0;</span><br><span class="line">        int max = 0,j = 0,i = 0;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        Set&lt;Character&gt; m = new HashSet&lt;Character&gt;();</span><br><span class="line">        while(i&lt;n&amp;&amp;j&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!m.contains(s.charAt(j)))</span><br><span class="line">            &#123;</span><br><span class="line">                m.add(s.charAt(j));</span><br><span class="line">                max = Math.max(max,j-i+1);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                m.remove(s.charAt(i++));//无论是否与第i个元素重复，此时都需要删掉此元素，因为后面要找的子问题不包括此元素。</span><br><span class="line">          &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-最大公共子字符串"><a href="#14-最大公共子字符串" class="headerlink" title="14 最大公共子字符串"></a>14 最大公共子字符串</h3><h4 id="首先找到字符串数组中最短的字符串-主要为了后面数组不越界-，之后利用两层循环找到最短的公共字符串。"><a href="#首先找到字符串数组中最短的字符串-主要为了后面数组不越界-，之后利用两层循环找到最短的公共字符串。" class="headerlink" title="首先找到字符串数组中最短的字符串(主要为了后面数组不越界)，之后利用两层循环找到最短的公共字符串。"></a>首先找到字符串数组中最短的字符串(主要为了后面数组不越界)，之后利用两层循环找到最短的公共字符串。</h4><p><code>时间复杂度o(n2)</code>  <code>空间复杂度o(1)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        int length = strs.length;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        if(length==0) return &quot;&quot;;</span><br><span class="line">        int min_length = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            if (min_length &gt; strs[i].length())</span><br><span class="line">                min_length = strs[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;min_length;j++)</span><br><span class="line">        &#123; for(int i=1;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strs[0].charAt(j)!=strs[i].charAt(j))</span><br><span class="line">                 return res;</span><br><span class="line">        &#125;</span><br><span class="line">         res += strs[0].charAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><ul>
<li>这是一个典型的动态规划问题，考虑temp保存当前最大的连续自序和，但要考虑temp保存的恰是以子序列的结束点为基准，所以递推关系式为temp = max(temp+num[i],num[i]) 此处的最大和要么是跟上一个子序列相加得到的，要么就是自己。 之后res用来保存最大的temp即是结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int temp = nums[0];</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        if(nums.size()==0) return 0;</span><br><span class="line">        for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = max(temp+nums[i],nums[i]);</span><br><span class="line">            res = max(res,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="13-罗马数字转为阿拉伯数字"><a href="#13-罗马数字转为阿拉伯数字" class="headerlink" title="13 罗马数字转为阿拉伯数字"></a>13 罗马数字转为阿拉伯数字</h3><h4 id="考虑特殊的数字-若下一位比前一位大则需要特殊处理，否则直接相加即可-记得用hash表将映射关系存储。"><a href="#考虑特殊的数字-若下一位比前一位大则需要特殊处理，否则直接相加即可-记得用hash表将映射关系存储。" class="headerlink" title="考虑特殊的数字 若下一位比前一位大则需要特殊处理，否则直接相加即可  记得用hash表将映射关系存储。"></a>考虑特殊的数字 若下一位比前一位大则需要特殊处理，否则直接相加即可  记得用hash表将映射关系存储。</h4><p><code>空间复杂度o(n)</code> <code>时间复杂度o(n)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&apos;I&apos;,1);</span><br><span class="line">        map.put(&apos;V&apos;,5);</span><br><span class="line">        map.put(&apos;X&apos;,10);</span><br><span class="line">        map.put(&apos;L&apos;,50);</span><br><span class="line">        map.put(&apos;C&apos;,100);</span><br><span class="line">        map.put(&apos;D&apos;,500);</span><br><span class="line">        map.put(&apos;M&apos;,1000);</span><br><span class="line">        for(int i=0;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==s.length()-1||(map.get(s.charAt(i))&gt;=map.get(s.charAt(i+1))))</span><br><span class="line">               res +=map.get(s.charAt(i));</span><br><span class="line">            else</span><br><span class="line">            &#123; res += map.get(s.charAt(i+1))-map.get(s.charAt(i));</span><br><span class="line">               i++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        return res;</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387 字符串中的第一个唯一字符"></a>387 字符串中的第一个唯一字符</h3><h4 id="第一次遍历，利用hashmap总结所有的字母出现的次数，之后再遍历一次，若value为1，则返回索引即可。"><a href="#第一次遍历，利用hashmap总结所有的字母出现的次数，之后再遍历一次，若value为1，则返回索引即可。" class="headerlink" title="第一次遍历，利用hashmap总结所有的字母出现的次数，之后再遍历一次，若value为1，则返回索引即可。"></a>第一次遍历，利用hashmap总结所有的字母出现的次数，之后再遍历一次，若value为1，则返回索引即可。</h4><p><code>时间复杂度o(n)``空间复杂度o(n)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int firstUniqChar(String s) &#123;</span><br><span class="line">        if(s.length()==0) return -1;</span><br><span class="line">        if(s.length()==1) return 0;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(map.containsKey(s.charAt(i))==false)       </span><br><span class="line">             map.put(s.charAt(i),1);    </span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                  int val = map.get(s.charAt(i))+1;</span><br><span class="line">                  map.put(s.charAt(i),val); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                for(int i=0;i&lt;s.length();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                  if( map.get(s.charAt(i))==1)</span><br><span class="line">                      return i;</span><br><span class="line">                &#125;</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28 实现strStr()"></a>28 实现strStr()</h3><h4 id="给定一个-haystack-字符串和一个-needle-字符串，在-haystack-字符串中找出-needle-字符串出现的第一个位置-从0开始-。如果不存在，则返回-1。"><a href="#给定一个-haystack-字符串和一个-needle-字符串，在-haystack-字符串中找出-needle-字符串出现的第一个位置-从0开始-。如果不存在，则返回-1。" class="headerlink" title="给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。"></a>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</h4><p>注意若needle为空，则返回0(java的indexOf())  采用暴力匹配法<br><code>时间复杂度o((n-m)m)``空间复杂度o(1)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if(needle.length()==0) return 0;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i=0;i&lt;=haystack.length()-needle.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            for(int j=0;j&lt;needle.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(needle.charAt(j)==haystack.charAt(i+j))&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(cnt==needle.length())</span><br><span class="line">                return i;</span><br><span class="line">            else</span><br><span class="line">                cnt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-找到最大的山谷和山峰的区间"><a href="#买卖股票的最佳时机-找到最大的山谷和山峰的区间" class="headerlink" title="买卖股票的最佳时机  (找到最大的山谷和山峰的区间)"></a>买卖股票的最佳时机  (找到最大的山谷和山峰的区间)</h3><ul>
<li><p>我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。<br>形式上，对于每组i和 j（其中 j &gt; i）我们需要找出max(prices[j]−prices[i])。</p>
<h4 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int maxProfit(int prices[]) &#123;</span><br><span class="line">        int maxprofit = 0;</span><br><span class="line">        for (int i = 0; i &lt; prices.length - 1; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; prices.length; j++) &#123;</span><br><span class="line">                int profit = prices[j] - prices[i];</span><br><span class="line">                if (profit &gt; maxprofit)</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：O(n^2)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<h4 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h4><ul>
<li>假设给定的数组为：[7, 1, 5, 3, 6, 4]</li>
<li>如果我们在图表上绘制给定数组中的数字，我们将会得到一个函数图</li>
<li>使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。</li>
<li>我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int minprof = 99999;</span><br><span class="line">        int maxprof = 0;</span><br><span class="line">        if(prices.size()==0) return 0;</span><br><span class="line">        for(int i=0;i&lt;prices.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i]&lt;minprof)&#123;</span><br><span class="line">                minprof = prices[i]; //更新最小的节点</span><br><span class="line">            &#125;</span><br><span class="line">            else if(prices[i]-minprof&gt; maxprof)</span><br><span class="line">            &#123;</span><br><span class="line">                maxprof = prices[i]-minprof;</span><br><span class="line">            &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        return maxprof;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>复杂度o(n)</p>
<h3 id="卖股票的最佳时机II（可以多次买卖，让利润最大）"><a href="#卖股票的最佳时机II（可以多次买卖，让利润最大）" class="headerlink" title="卖股票的最佳时机II（可以多次买卖，让利润最大）"></a>卖股票的最佳时机II（可以多次买卖，让利润最大）</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>一次遍历：复杂度o(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int profit = 0;</span><br><span class="line">        if(prices.size()==0) return 0;</span><br><span class="line">        for(int i=0;i&lt;prices.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i]&lt;prices[i+1])</span><br><span class="line">                profit +=prices[i+1]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h3><p>如果数组中有出现两次以上的元素，则返回true,否则返回false</p>
<h4 id="方法1：调用sort排序-之后遍历，一旦发现有相同的元素直接return-复杂度o-nlogn"><a href="#方法1：调用sort排序-之后遍历，一旦发现有相同的元素直接return-复杂度o-nlogn" class="headerlink" title="方法1：调用sort排序,之后遍历，一旦发现有相同的元素直接return    复杂度o(nlogn)"></a>方法1：调用sort排序,之后遍历，一旦发现有相同的元素直接return    复杂度o(nlogn)</h4><h4 id="方法2：set-将元素放入set中，每次放进去的时候进行对比。"><a href="#方法2：set-将元素放入set中，每次放进去的时候进行对比。" class="headerlink" title="方法2：set 将元素放入set中，每次放进去的时候进行对比。"></a>方法2：set 将元素放入set中，每次放进去的时候进行对比。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">         set &lt;int&gt; hashset;</span><br><span class="line">        if(nums.size()&lt;=1) return false;</span><br><span class="line">        for(int i=0 ;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(hashset.count(nums[i])==1)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                hashset.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法3：hash表"><a href="#方法3：hash表" class="headerlink" title="方法3：hash表"></a>方法3：hash表</h4><h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><ul>
<li>考虑利用%进行翻转，翻转k次的结果等于l=k%n次。</li>
<li>首先翻转所有的数组，之后翻转l的部分，最后翻转n-l的部分即可</li>
<li>时间复杂度o(n) 空间复杂度o(1)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">  void  reverse(vector&lt;int&gt; &amp;nums, int left, int right)</span><br><span class="line">    &#123;     int temp =0;</span><br><span class="line">        while(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        if(k==0) return ;</span><br><span class="line">        k = k%nums.size();</span><br><span class="line">        reverse(nums,0,nums.size()-1);</span><br><span class="line">        reverse(nums,0,k-1);</span><br><span class="line">        reverse(nums,k,nums.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><h4 id="Way1：-暴力解法-创建新数组存取res，之后利用两层for循环逐一挪动窗口并进行判断，将此窗口的最值插入res中即可。-O（n-k）k为windows大小"><a href="#Way1：-暴力解法-创建新数组存取res，之后利用两层for循环逐一挪动窗口并进行判断，将此窗口的最值插入res中即可。-O（n-k）k为windows大小" class="headerlink" title="Way1： 暴力解法 创建新数组存取res，之后利用两层for循环逐一挪动窗口并进行判断，将此窗口的最值插入res中即可。 O（n*k）k为windows大小"></a>Way1： 暴力解法 创建新数组存取res，之后利用两层for循环逐一挪动窗口并进行判断，将此窗口的最值插入res中即可。 O（n*k）k为windows大小</h4><h3 id="寻找两个有序数组的中位数-要求o-log-m-n"><a href="#寻找两个有序数组的中位数-要求o-log-m-n" class="headerlink" title="寻找两个有序数组的中位数 要求o(log(m+n))"></a>寻找两个有序数组的中位数 要求o(log(m+n))</h3><h4 id="Way1-merge两个数组-之后排序-最后直接取中位数即可。-O-m-n-log-m-n"><a href="#Way1-merge两个数组-之后排序-最后直接取中位数即可。-O-m-n-log-m-n" class="headerlink" title="Way1:merge两个数组 之后排序 最后直接取中位数即可。 O((m+n)log(m+n))"></a>Way1:merge两个数组 之后排序 最后直接取中位数即可。 O((m+n)log(m+n))</h4><h4 id="Way2-利用两个指针，分别指向两个数组的head，然后挪动到中位数即可。O-m-n-2"><a href="#Way2-利用两个指针，分别指向两个数组的head，然后挪动到中位数即可。O-m-n-2" class="headerlink" title="Way2:利用两个指针，分别指向两个数组的head，然后挪动到中位数即可。O((m+n)/2)"></a>Way2:利用两个指针，分别指向两个数组的head，然后挪动到中位数即可。O((m+n)/2)</h4><h4 id="Way3-一看见log的复杂度就要想到分治算法-此问题可以转化为min-k问题，即寻找数组中第k小的元素。"><a href="#Way3-一看见log的复杂度就要想到分治算法-此问题可以转化为min-k问题，即寻找数组中第k小的元素。" class="headerlink" title="Way3: 一看见log的复杂度就要想到分治算法,此问题可以转化为min k问题，即寻找数组中第k小的元素。"></a>Way3: 一看见log的复杂度就要想到分治算法,此问题可以转化为min k问题，即寻找数组中第k小的元素。</h4><p>最后从medianof two sorted arrays中看到了一种非常好的方法<br>该方法的核心是将原问题转变成一个寻找第k小数的问题（假设两个原序列升序排列），这样中位数实际上是第(m+n)/2小的数。所以只要解决了第k小数的问题，原问题也得以解决。</p>
<p>首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：&gt;、&lt;和=。如果A[k/2-1]&lt;B[k/2-1]，这表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k/2-1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。</p>
<p>证明也很简单，可以采用反证法。假设A[k/2-1]大于合并之后的第k小值，我们不妨假定其为第（k+1）小值。由于A[k/2-1]小于B[k/2-1]，所以B[k/2-1]至少是第（k+2）小值。但实际上，在A中至多存在k/2-1个元素小于A[k/2-1]，B中也至多存在k/2-1个元素小于A[k/2-1]，所以小于A[k/2-1]的元素个数至多有k/2+ k/2-2，小于k，这与A[k/2-1]是第（k+1）的数矛盾。</p>
<p>当A[k/2-1]&gt;B[k/2-1]时存在类似的结论。</p>
<p>当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。)</p>
<p>通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件：</p>
<p>如果A或者B为空，则直接返回B[k-1]或者A[k-1]；<br>如果k为1，我们只需要返回A[0]和B[0]中的较小值；<br>如果A[k/2-1]=B[k/2-1]，返回其中一个；<br>最终实现的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">double findKth(int a[], int m, int b[], int n, int k)</span><br><span class="line">&#123;</span><br><span class="line">    //always assume that m is equal or smaller than n</span><br><span class="line">    if (m &gt; n)</span><br><span class="line">        return findKth(b, n, a, m, k);</span><br><span class="line">    if (m == 0)</span><br><span class="line">        return b[k - 1];</span><br><span class="line">    if (k == 1)</span><br><span class="line">        return min(a[0], b[0]);</span><br><span class="line">    //divide k into two parts</span><br><span class="line">    int pa = min(k / 2, m), pb = k - pa;</span><br><span class="line">    if (a[pa - 1] &lt; b[pb - 1])</span><br><span class="line">        return findKth(a + pa, m - pa, b, n, k - pa);</span><br><span class="line">    else if (a[pa - 1] &gt; b[pb - 1])</span><br><span class="line">        return findKth(a, m, b + pb, n - pb, k - pb);</span><br><span class="line">    else</span><br><span class="line">        return a[pa - 1];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(int A[], int m, int B[], int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int total = m + n;</span><br><span class="line">        if (total &amp; 0x1)  //若为奇数则total最后一位二进制为1</span><br><span class="line">            return findKth(A, m, B, n, total / 2 + 1);</span><br><span class="line">        else</span><br><span class="line">            return (findKth(A, m, B, n, total / 2)</span><br><span class="line">                    + findKth(A, m, B, n, total / 2 + 1)) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看出，代码非常简洁，而且效率也很高。在最好情况下，每次都有k一半的元素被删除，所以算法复杂度为logk，由于求中位数时k为（m+n）/2，所以算法复杂度为log(m+n)。</p>
<h5 id="C-code"><a href="#C-code" class="headerlink" title="C++ code:"></a>C++ code:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; trans(vector&lt;int&gt; &amp;num,int p) //注意vector当作形参的时候不是地址，地址应该为&amp;a[0] ,而此处递归需要传入一个vector对象，不是地址，注意与数组的区别。此函数用于构造转换的vector。</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for(int i=p;i&lt;num.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">int findk(vector&lt;int&gt; nums1,int m, vector&lt;int&gt; nums2,int n, int k)//用于寻找最小的K元素</span><br><span class="line">&#123;</span><br><span class="line">        if(m&gt;n)</span><br><span class="line">            return findk(nums2,n,nums1,m,k);</span><br><span class="line">        if(m==0)</span><br><span class="line">            return nums2[k-1];</span><br><span class="line">        if(k==1)</span><br><span class="line">            return min(nums1[0],nums2[0]);</span><br><span class="line">        int pa = min(k/2,m),pb = k-pa;</span><br><span class="line">        if(nums1[pa-1]&lt;nums2[pb-1])</span><br><span class="line">        &#123;vector&lt;int&gt; nums3 = trans(nums1,pa);</span><br><span class="line">          return    findk(nums3,m-pa,nums2,n,k-pa);&#125;</span><br><span class="line">        if(nums1[pa-1]&gt;nums2[pb-1])</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; nums4 = trans(nums2,pb);</span><br><span class="line">             return findk(nums1,m,nums4,n-pb,k-pb);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        else</span><br><span class="line">            return nums1[pa-1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">       int m = nums1.size();</span><br><span class="line">       int n = nums2.size();</span><br><span class="line">        int total = nums1.size()+nums2.size();</span><br><span class="line">        if(total &amp; 0x1)  </span><br><span class="line">            return double(findk(nums1,m,nums2,n,total/2+1));</span><br><span class="line">        else</span><br><span class="line">            return 0.5*(double(findk(nums1,m,nums2,n,total/2))+double(findk(nums1,m,nums2,n,(total/2)+1)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283 移动0"></a>283 移动0</h3><h4 id="Way1-引入队列queue，遍历一遍数组，将非零的值按顺序存入，在遍历一遍，将其覆盖原来的数组内容，最后补0"><a href="#Way1-引入队列queue，遍历一遍数组，将非零的值按顺序存入，在遍历一遍，将其覆盖原来的数组内容，最后补0" class="headerlink" title="Way1:引入队列queue，遍历一遍数组，将非零的值按顺序存入，在遍历一遍，将其覆盖原来的数组内容，最后补0"></a>Way1:引入队列queue，遍历一遍数组，将非零的值按顺序存入，在遍历一遍，将其覆盖原来的数组内容，最后补0</h4><p> 时间复杂度o(n) 空间复杂度o(n)</p>
<h4 id="Way2-双指针法-slow指针保证前面的元素都是非0，fast向后遍历，一旦发现非零元素，就跟slow交换，之后slow-即可-（这样slow和fast之间全是0）"><a href="#Way2-双指针法-slow指针保证前面的元素都是非0，fast向后遍历，一旦发现非零元素，就跟slow交换，之后slow-即可-（这样slow和fast之间全是0）" class="headerlink" title="Way2:双指针法  slow指针保证前面的元素都是非0，fast向后遍历，一旦发现非零元素，就跟slow交换，之后slow++即可 （这样slow和fast之间全是0）"></a>Way2:双指针法  slow指针保证前面的元素都是非0，fast向后遍历，一旦发现非零元素，就跟slow交换，之后slow++即可 （这样slow和fast之间全是0）</h4><p> 时间复杂度o(n) 空间复杂度o(1)</p>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h3><h4 id="Way-此题目要求o-1-的空间复杂度，其本质上跟之前的移动0是一样的，只要把需要移除的元素都放到最后即可完成任务。同样采用双指针可以解决。"><a href="#Way-此题目要求o-1-的空间复杂度，其本质上跟之前的移动0是一样的，只要把需要移除的元素都放到最后即可完成任务。同样采用双指针可以解决。" class="headerlink" title="Way 此题目要求o(1)的空间复杂度，其本质上跟之前的移动0是一样的，只要把需要移除的元素都放到最后即可完成任务。同样采用双指针可以解决。"></a>Way 此题目要求o(1)的空间复杂度，其本质上跟之前的移动0是一样的，只要把需要移除的元素都放到最后即可完成任务。同样采用双指针可以解决。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int m = nums.size();</span><br><span class="line">        if(m==0) return 0;</span><br><span class="line">        int slow=0,fast=0;</span><br><span class="line">        for(slow=0,fast=0;fast&lt;m;fast++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[fast]!=val)</span><br><span class="line">                swap(nums[slow++],nums[fast]);</span><br><span class="line">        &#125;</span><br><span class="line">    return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66 加一"></a>66 加一</h3><h4 id="Way-加一关键问题在于考虑何时需要进位，一个数加一需要进位的话就是所有的数都是9，只要有不是9的，则此为加1，其后面的数都为0即可。则按照此思路只需要从后向前遍历依次即可。时间复杂度O-n-空间o-1"><a href="#Way-加一关键问题在于考虑何时需要进位，一个数加一需要进位的话就是所有的数都是9，只要有不是9的，则此为加1，其后面的数都为0即可。则按照此思路只需要从后向前遍历依次即可。时间复杂度O-n-空间o-1" class="headerlink" title="Way 加一关键问题在于考虑何时需要进位，一个数加一需要进位的话就是所有的数都是9，只要有不是9的，则此为加1，其后面的数都为0即可。则按照此思路只需要从后向前遍历依次即可。时间复杂度O(n)  空间o(1)"></a>Way 加一关键问题在于考虑何时需要进位，一个数加一需要进位的话就是所有的数都是9，只要有不是9的，则此为加1，其后面的数都为0即可。则按照此思路只需要从后向前遍历依次即可。时间复杂度O(n)  空间o(1)</h4><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88 合并两个有序数组"></a>88 合并两个有序数组</h3><h4 id="Merge与之前的寻找两个有序数组的中位数类似，此外也是归并排序中的核心步骤，引入新的辅助数组和双指针，即可完成merge"><a href="#Merge与之前的寻找两个有序数组的中位数类似，此外也是归并排序中的核心步骤，引入新的辅助数组和双指针，即可完成merge" class="headerlink" title="Merge与之前的寻找两个有序数组的中位数类似，此外也是归并排序中的核心步骤，引入新的辅助数组和双指针，即可完成merge"></a>Merge与之前的寻找两个有序数组的中位数类似，此外也是归并排序中的核心步骤，引入新的辅助数组和双指针，即可完成merge</h4><p>时间复杂度 o(n) 空间复杂度o(n)</p>
<h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268 缺失数字"></a>268 缺失数字</h3><h4 id="Way1-利用等差数列求和得到总和-然后遍历数组即可得到结果"><a href="#Way1-利用等差数列求和得到总和-然后遍历数组即可得到结果" class="headerlink" title="Way1 利用等差数列求和得到总和 然后遍历数组即可得到结果"></a>Way1 利用等差数列求和得到总和 然后遍历数组即可得到结果</h4><p>时间复杂度 o(n)  空间o(1)</p>
<h4 id="Way2-排序后跟下标进行对比-不同则返回下标即可"><a href="#Way2-排序后跟下标进行对比-不同则返回下标即可" class="headerlink" title="Way2  排序后跟下标进行对比 不同则返回下标即可"></a>Way2  排序后跟下标进行对比 不同则返回下标即可</h4><p>此方法不满足复杂度要求 最快的快排也只有o(nlogn)</p>
<h3 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169 求众数"></a>169 求众数</h3><h4 id="Way1-排序后取中位数即可"><a href="#Way1-排序后取中位数即可" class="headerlink" title="Way1 排序后取中位数即可"></a>Way1 排序后取中位数即可</h4><h4 id="Way2-利用hashmap来记录每个key出现的次数，记为value-之后选最大的value即可"><a href="#Way2-利用hashmap来记录每个key出现的次数，记为value-之后选最大的value即可" class="headerlink" title="Way2 利用hashmap来记录每个key出现的次数，记为value,之后选最大的value即可"></a>Way2 利用hashmap来记录每个key出现的次数，记为value,之后选最大的value即可</h4><h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h3><ul>
<li>主要就是抓住每一层的规律，其每层首尾都为1，其余部分都是由上一层算出来的，注意单独处理第一层即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        for(int i=0;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            temp.push_back(1);</span><br><span class="line">            if(i==0) </span><br><span class="line">            &#123;     result.push_back(temp);</span><br><span class="line">                continue;&#125;</span><br><span class="line">            for(int j=0;j&lt;i-1;j++) //注意终止条件的判断</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(result[i-1][j]+result[i-1][j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(1);</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="链表部分："><a href="#链表部分：" class="headerlink" title="链表部分："></a>链表部分：</h2><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237 删除链表中的节点"></a>237 删除链表中的节点</h3><h4 id="此题特殊在于函数传入的是要删除的节点的指针，所以无法找到prev而进行删除工作，而题目只要求val删除，考虑将后面的元素挪过来，然后将其覆盖。"><a href="#此题特殊在于函数传入的是要删除的节点的指针，所以无法找到prev而进行删除工作，而题目只要求val删除，考虑将后面的元素挪过来，然后将其覆盖。" class="headerlink" title="此题特殊在于函数传入的是要删除的节点的指针，所以无法找到prev而进行删除工作，而题目只要求val删除，考虑将后面的元素挪过来，然后将其覆盖。"></a>此题特殊在于函数传入的是要删除的节点的指针，所以无法找到prev而进行删除工作，而题目只要求val删除，考虑将后面的元素挪过来，然后将其覆盖。</h4><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h3><h4 id="Way1-递归"><a href="#Way1-递归" class="headerlink" title="Way1 递归"></a>Way1 递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(l1==NULL)</span><br><span class="line">            return l2;</span><br><span class="line">        else if(l2==NULL)</span><br><span class="line">            return l1;</span><br><span class="line">        else if(l1-&gt;val&lt;=l2-&gt;val)</span><br><span class="line">        &#123;  l1-&gt;next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            return l1;&#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">        return l2;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Way2-类比归并排序的merge来做，数组的话需要辅助数组，此处需要辅助指针，两个指针一个用来遍历所有的链表，一个记住链表头部用于返回。"><a href="#Way2-类比归并排序的merge来做，数组的话需要辅助数组，此处需要辅助指针，两个指针一个用来遍历所有的链表，一个记住链表头部用于返回。" class="headerlink" title="Way2 类比归并排序的merge来做，数组的话需要辅助数组，此处需要辅助指针，两个指针一个用来遍历所有的链表，一个记住链表头部用于返回。"></a>Way2 类比归并排序的merge来做，数组的话需要辅助数组，此处需要辅助指针，两个指针一个用来遍历所有的链表，一个记住链表头部用于返回。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">    ListNode * q = new ListNode(0);</span><br><span class="line">    ListNode * p = q;  注意设置两个指针的含义</span><br><span class="line">        if(l1==NULL) return l2;</span><br><span class="line">        if(l2==NULL) return l1;</span><br><span class="line">        while(l1!=NULL &amp;&amp; l2!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            if(l1-&gt;val&lt;=l2-&gt;val)</span><br><span class="line">               &#123;p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;&#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">        if(l1==NULL)</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        else if(l2==NULL)</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">       return q-&gt;next; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h3><h4 id="Way1-迭代完成"><a href="#Way1-迭代完成" class="headerlink" title="Way1:迭代完成"></a>Way1:迭代完成</h4><p>利用两个指针完成，迭代完成，一个指针不断移动，一个指针一直标记新反转的头，时间复杂度o(n),空间复杂度o(1).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode*p = NULL;//p一直标记新反转的链表的头</span><br><span class="line">        ListNode* q = head;//不断移动修改链表</span><br><span class="line">        while(q!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp = q-&gt;next;</span><br><span class="line">             q-&gt;next = p;</span><br><span class="line">             p = q;</span><br><span class="line">             q = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Way2：递归"><a href="#Way2：递归" class="headerlink" title="Way2：递归"></a>Way2：递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">     if(head==null) &#123;</span><br><span class="line">		   return null;</span><br><span class="line">	   &#125;  </span><br><span class="line">	ListNode last=head;</span><br><span class="line">	ListNode current=last.next;</span><br><span class="line">	  </span><br><span class="line">	   return reverse(head,last,current);</span><br><span class="line">    &#125;</span><br><span class="line">  private ListNode reverse(ListNode head, ListNode last, ListNode current) &#123;</span><br><span class="line">	if(current==null) &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	last.next=current.next;</span><br><span class="line">	ListNode temp=current.next;</span><br><span class="line">	current.next=head;</span><br><span class="line">	//注意此时reverse方法的参数</span><br><span class="line">	return reverse(current,last,temp);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234 回文链表"></a>234 回文链表</h3><h4 id="Way1-对链表进行计数，将其一半压入栈中，然后与另一部分进行对比，即可。"><a href="#Way1-对链表进行计数，将其一半压入栈中，然后与另一部分进行对比，即可。" class="headerlink" title="Way1 对链表进行计数，将其一半压入栈中，然后与另一部分进行对比，即可。"></a>Way1 对链表进行计数，将其一半压入栈中，然后与另一部分进行对比，即可。</h4><p>时间复杂度o(n) 空间复杂度o(n)</p>
<h4 id="Way2-为了降低空间复杂度，利用快慢指针找到链表终点，之后将链表后半部分反转，最后判断两个链表是否相等。"><a href="#Way2-为了降低空间复杂度，利用快慢指针找到链表终点，之后将链表后半部分反转，最后判断两个链表是否相等。" class="headerlink" title="Way2 为了降低空间复杂度，利用快慢指针找到链表终点，之后将链表后半部分反转，最后判断两个链表是否相等。"></a>Way2 为了降低空间复杂度，利用快慢指针找到链表终点，之后将链表后半部分反转，最后判断两个链表是否相等。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* findmiddle(ListNode* head)&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * reverse(ListNode * head)</span><br><span class="line">    &#123;</span><br><span class="line">    ListNode* p = NULL;</span><br><span class="line">    ListNode* q = head;</span><br><span class="line">        while(q!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      ListNode* temp = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        //先找到链表中间，slow指向第一个，fast指向第二个，若为奇数，slow会停在最中间，若为偶数会停在1/2左边。</span><br><span class="line">        if(head==NULL||head-&gt;next==NULL) return true;</span><br><span class="line">        ListNode* mid = findmiddle(head);</span><br><span class="line">        mid = mid-&gt;next;</span><br><span class="line">        mid = reverse(mid);</span><br><span class="line">        while(mid&amp;&amp;head)&#123;</span><br><span class="line">        if(mid-&gt;val!=head-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        mid = mid-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h3><h4 id="Way1-固定a链表，遍历b链表，如果有相同的next指针则说明相交点。"><a href="#Way1-固定a链表，遍历b链表，如果有相同的next指针则说明相交点。" class="headerlink" title="Way1:固定a链表，遍历b链表，如果有相同的next指针则说明相交点。"></a>Way1:固定a链表，遍历b链表，如果有相同的next指针则说明相交点。</h4><p>时间复杂度o(n²)</p>
<h4 id="Way2-hash法"><a href="#Way2-hash法" class="headerlink" title="Way2:hash法"></a>Way2:hash法</h4><p>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 b是否在哈希表中。若在，则为相交结点。<br>时间复杂度 : O(m+n)<br>空间复杂度 : O(m)或O(n)。</p>
<h4 id="Way3-双指针法-非常巧妙-都遍历一遍如果有相交点必定会相遇"><a href="#Way3-双指针法-非常巧妙-都遍历一遍如果有相交点必定会相遇" class="headerlink" title="Way3:双指针法 非常巧妙 都遍历一遍如果有相交点必定会相遇"></a>Way3:双指针法 非常巧妙 都遍历一遍如果有相交点必定会相遇</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if(headA==NULL||headB==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        ListNode* a = headA;</span><br><span class="line">        ListNode* b = headB;</span><br><span class="line">        while(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            a=(a==NULL)?headB:a-&gt;next;</span><br><span class="line">            b=(b==NULL)?headA:b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    return a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h3><h4 id="way1-考虑快慢指针法，如若有环，则一定回相遇，可以类比物理中的追击问题，如果fast指针已经走到链表结尾，则说明没有环，因为有环的话也不会结束的。"><a href="#way1-考虑快慢指针法，如若有环，则一定回相遇，可以类比物理中的追击问题，如果fast指针已经走到链表结尾，则说明没有环，因为有环的话也不会结束的。" class="headerlink" title="way1:考虑快慢指针法，如若有环，则一定回相遇，可以类比物理中的追击问题，如果fast指针已经走到链表结尾，则说明没有环，因为有环的话也不会结束的。"></a>way1:考虑快慢指针法，如若有环，则一定回相遇，可以类比物理中的追击问题，如果fast指针已经走到链表结尾，则说明没有环，因为有环的话也不会结束的。</h4><p>时间复杂度o(n),空间复杂度o(1)<br>要注意编程的时候程序的<code>健壮性</code>，考虑特殊情况下程序的结果。<br>还有就是指针是否有效的问题，因为要访问<code>fast-&gt;next-&gt;next</code>,所以需要注意while的判断条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if(head==NULL||head-&gt;next==NULL) return false;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123;</span><br><span class="line">          if(slow==fast)</span><br><span class="line">              return true;</span><br><span class="line">         else&#123;</span><br><span class="line">             slow = slow-&gt;next;</span><br><span class="line">             fast = fast-&gt;next-&gt;next;    </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19 删除链表的倒数第N个节点"></a>19 删除链表的倒数第N个节点</h2><p>注意哑节点的使用（不然无法应对特殊情况，比如删除第一个，n+1就会超出范围）<br>此处使用双指针 只需遍历一次即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode res = new ListNode(0);</span><br><span class="line">        res.next = head;</span><br><span class="line">        ListNode  curr = res, p = res;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)</span><br><span class="line">            p = p.next;</span><br><span class="line">    while(p!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">        curr.next = curr.next.next;</span><br><span class="line">    return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈（此后语言改为JAVA）"><a href="#栈（此后语言改为JAVA）" class="headerlink" title="栈（此后语言改为JAVA）"></a>栈（此后语言改为JAVA）</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h3><h4 id="way1-此题为栈的典型应用，由于刚改为java刷题，很多小问题需要注意。"><a href="#way1-此题为栈的典型应用，由于刚改为java刷题，很多小问题需要注意。" class="headerlink" title="way1:此题为栈的典型应用，由于刚改为java刷题，很多小问题需要注意。"></a>way1:此题为栈的典型应用，由于刚改为java刷题，很多小问题需要注意。</h4><p>判断是否为有效括号首先可以这样想，一旦有个左括号，如果下一个符号不是右括号，则需要等待，若为右括号，则需要一定与它匹配，也就是说，核心问题是一个最近匹配问题。所以我们如果采用栈，遍历整个字符串，有左括号则压进去，有右括号则出栈，若匹配则继续向下遍历，若不匹配则不对(还可能出现 如果右括号多 栈空则也是不匹配  左括号多遍历完栈不为空也不匹配)  此外要注意 map的使用方法。<br><br>时间复杂度 O（n） 空间复杂度o(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        if(len==0 ) //特殊情况算匹配</span><br><span class="line">            return true;</span><br><span class="line">        if((len%2)!=0) //若为奇数则直接退出</span><br><span class="line">            return false;</span><br><span class="line">        HashMap map = new HashMap(); //一定是key,value</span><br><span class="line">        map.put(&apos;)&apos;,&apos;(&apos;);</span><br><span class="line">        map.put(&apos;&#125;&apos;,&apos;&#123;&apos;);</span><br><span class="line">        map.put(&apos;]&apos;,&apos;[&apos;);</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack(); </span><br><span class="line">        for(char val:s.toCharArray()) //注意这种for循环以及string类的一些方法</span><br><span class="line">	&#123;</span><br><span class="line">           if(val==&apos;(&apos;||val==&apos;&#123;&apos;||val==&apos;[&apos;)</span><br><span class="line">            stack.push(val);</span><br><span class="line">            if((val==&apos;)&apos;||val==&apos;&#125;&apos;||val==&apos;]&apos;)&amp;&amp;(stack.isEmpty()||stack.pop()!=map.get(val))) //栈提前空或者不匹配都是错的</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();//巧妙转换 遍历完栈应该为空才说明正常 如不是则说明左括号多</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="155最小栈"><a href="#155最小栈" class="headerlink" title="155最小栈"></a>155最小栈</h3><h4 id="way1：同步辅助栈"><a href="#way1：同步辅助栈" class="headerlink" title="way1：同步辅助栈"></a>way1：同步辅助栈</h4><p>采用利用空间换时间的方法，题目要求getMin在常数时间内返回，则需额外存储。不然无法完成。采用两个栈完成，一个用来存储数据，一个用来标注最小的数。<br><code>时间复杂度o(1)</code>  <code>空间复杂度o(n)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; data;//数据栈</span><br><span class="line">    private Stack&lt;Integer&gt; min;//辅助栈</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        this.data = new Stack&lt;Integer&gt;();//初始化</span><br><span class="line">        this.min = new Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        this.data.push(x);</span><br><span class="line">        if(this.min.isEmpty()||this.getMin()&gt;=x) //注意辅助栈不是存储一个数据，需要考虑刚开始以及后面要用等号（考虑有多个相同最小值）</span><br><span class="line">            this.min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        if(this.data.isEmpty()) //如果栈空则抛出异常</span><br><span class="line">            throw new RuntimeException(&quot;your stack is empty!&quot;);</span><br><span class="line">       int val = this.data.pop();//注意判断出栈的是否是最小的元素，不是的话不用删辅助栈里面的</span><br><span class="line">       if(val == this.getMin())</span><br><span class="line">           this.min.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        if(this.data.isEmpty())</span><br><span class="line">            throw new RuntimeException(&quot;your stack is empty!&quot;);</span><br><span class="line">        return this.data.peek(); //注意peek不会删除元素，pop会</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        if(this.min.isEmpty())  </span><br><span class="line">            throw new RuntimeException(&quot;your stack is empty!&quot;);</span><br><span class="line">        return this.min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack obj = new MinStack();</span><br><span class="line"> * obj.push(x);</span><br><span class="line"> * obj.pop();</span><br><span class="line"> * int param_3 = obj.top();</span><br><span class="line"> * int param_4 = obj.getMin();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="101-对称二叉树（镜像二叉树）"><a href="#101-对称二叉树（镜像二叉树）" class="headerlink" title="101 对称二叉树（镜像二叉树）"></a>101 对称二叉树（镜像二叉树）</h3><h4 id="way1-递归解法"><a href="#way1-递归解法" class="headerlink" title="way1:递归解法"></a>way1:递归解法</h4><p>此题本质上就是一个对称问题，满足对称二叉树的要求无非就是以中间为线可以对折，那么需要满足的就是1)根节点val相同 2）每个树的右子树都与另一个树的左子树镜像对称。<br><code>时间复杂度0(n)</code> <code>空间复杂度o(n)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return judge(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">        public boolean judge(TreeNode r1,TreeNode r2)&#123;</span><br><span class="line">            if(r1==null&amp;&amp;r2==null) return true;</span><br><span class="line">            if(r1==null||r2==null) return false;</span><br><span class="line">            return (r1.val==r2.val)&amp;&amp;judge(r1.left,r2.right)&amp;&amp;judge(r1.right,r2.left);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//注意此方法好理解 </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return true; //判断根节点</span><br><span class="line">        return judge(root.left,root.right);  </span><br><span class="line">    &#125;</span><br><span class="line">        public boolean judge(TreeNode r1,TreeNode r2)&#123;</span><br><span class="line">            if(r1==null&amp;&amp;r2==null) return true;</span><br><span class="line">            if(r1==null||r2==null) return false;</span><br><span class="line">            return (r1.val==r2.val)&amp;&amp;judge(r1.left,r2.right)&amp;&amp;judge(r1.right,r2.left);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="way2-迭代解法"><a href="#way2-迭代解法" class="headerlink" title="way2:迭代解法"></a>way2:迭代解法</h4><p>利用层次遍历的方法对二叉树进行遍历，注意入队列的顺序按照镜像来。<br><code>时间复杂度o（h)</code>  <code>空间复杂度o(n)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">       if(root==null) return true;</span><br><span class="line">        Queue&lt;TreeNode&gt; c =new LinkedList&lt;&gt;();</span><br><span class="line">        c.add(root.left);</span><br><span class="line">        c.add(root.right);</span><br><span class="line">        while(!c.isEmpty())&#123;</span><br><span class="line">            TreeNode t1 = c.poll();</span><br><span class="line">            TreeNode t2 = c.poll();</span><br><span class="line">            if(t1==null&amp;&amp;t2==null) continue;</span><br><span class="line">            if(t1==null||t2==null||(t1.val!=t2.val)) return false;</span><br><span class="line">            c.add(t1.left);</span><br><span class="line">            c.add(t2.right);</span><br><span class="line">            c.add(t1.right);</span><br><span class="line">            c.add(t2.left);    </span><br><span class="line">          &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转为二叉平衡搜索树"><a href="#108-将有序数组转为二叉平衡搜索树" class="headerlink" title="108 将有序数组转为二叉平衡搜索树"></a>108 将有序数组转为二叉平衡搜索树</h3><h4 id="way1-递归解法-1"><a href="#way1-递归解法-1" class="headerlink" title="way1 递归解法"></a>way1 递归解法</h4><p>此题核心在于搜索二叉树的中序遍历一定是一个有序的数组，所以此题目核心便是一个按照中序遍历的思想去构造二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        return   balance(nums,0,nums.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">   private  TreeNode  balance(int[] nums,int l,int r)&#123;</span><br><span class="line">       if(l&gt;r) return null; //注意边界条件一定是l&gt;r，相等时不可退出 需要将其赋值进去。</span><br><span class="line">       int mid = (l+r)&gt;&gt;&gt;1;// 注意中点利用（l+r）/2可能溢出（可能回超过int的表示范围），此方法为java JDK内部实现，不会溢出。也可以采用l+（r-l)/2</span><br><span class="line">       TreeNode root = new TreeNode(nums[mid]);</span><br><span class="line">       root.left = balance(nums,l,mid-1); </span><br><span class="line">       root.right = balance(nums,mid+1,r);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="104-求二叉树的深度"><a href="#104-求二叉树的深度" class="headerlink" title="104 求二叉树的深度"></a>104 求二叉树的深度</h3><p>way1:递归<br>利用dfs遍历一遍即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)</span><br><span class="line">            return 0;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">         int left = maxDepth(root.left);</span><br><span class="line">        int right = maxDepth(root.right);</span><br><span class="line">         return Math.max(left,right)+1;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><h3 id="way1-此题本质上是斐波拉契数列的问题，考虑动态规划的思想-总方法应该是n-1与n-2的和，则找到递推公式dp-n-dp-n-1-dp-n-2"><a href="#way1-此题本质上是斐波拉契数列的问题，考虑动态规划的思想-总方法应该是n-1与n-2的和，则找到递推公式dp-n-dp-n-1-dp-n-2" class="headerlink" title="way1 :此题本质上是斐波拉契数列的问题，考虑动态规划的思想 总方法应该是n-1与n-2的和，则找到递推公式dp[n]=dp[n-1]+dp[n-2]"></a>way1 :此题本质上是斐波拉契数列的问题，考虑动态规划的思想 总方法应该是n-1与n-2的和，则找到递推公式dp[n]=dp[n-1]+dp[n-2]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)</span><br><span class="line">            dp[i]= dp[i-1]+dp[i-2];</span><br><span class="line">    return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="way2-利用通项公式（可能会损失精度）"><a href="#way2-利用通项公式（可能会损失精度）" class="headerlink" title="way2:利用通项公式（可能会损失精度）"></a>way2:利用通项公式（可能会损失精度）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        double sqrt_5 = Math.sqrt(5);</span><br><span class="line">        double fib_n = Math.pow((1 + sqrt_5) / 2, n + 1) - Math.pow((1 - sqrt_5) / 2,n + 1);</span><br><span class="line">        return (int)(fib_n / sqrt_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="344-翻转字符串（注意空间复杂度必须是o-1"><a href="#344-翻转字符串（注意空间复杂度必须是o-1" class="headerlink" title="344 翻转字符串（注意空间复杂度必须是o(1))"></a>344 翻转字符串（注意空间复杂度必须是o(1))</h2><h3 id="way1-利用双指针法"><a href="#way1-利用双指针法" class="headerlink" title="way1 利用双指针法"></a>way1 利用双指针法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">        if(s.length==0) return;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = s.length-1;</span><br><span class="line">        while(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            char temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/06/leetcode-mark/" data-id="ck4doeok30001lsk4i7iw217p"
         class="article-share-link">Share</a>
      
    </footer>

  </div>

  

  

</article>



      
        

<article id="post-Java" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/10/06/Java/">Java</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/10/06/Java/" class="article-date">
  <time datetime="2019-10-06T06:05:18.000Z" itemprop="datePublished">2019-10-06</time>
</a>
        
      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java技术"><a href="#Java技术" class="headerlink" title="Java技术"></a>Java技术</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java基础《Core Java Ⅰ、Ⅱ》</span><br><span class="line">Java虚拟机 — 《深入理解Java虚拟机》</span><br><span class="line">多线程 — 《Java多线程编程实战指南（核心篇）》《Java并发编程实战》</span><br><span class="line">多线程相关源码</span><br><span class="line">集合相关源码</span><br></pre></td></tr></table></figure>

<h2 id="Web-amp-框架-amp-中间件"><a href="#Web-amp-框架-amp-中间件" class="headerlink" title="Web&amp;框架&amp;中间件"></a>Web&amp;框架&amp;中间件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java Web — 《Servlet、JSP和Spring MVC初学指南》</span><br><span class="line">Spring — 《Spring源码深度解析》</span><br><span class="line">系统架构和中间件</span><br><span class="line">《大型网站技术架构 核心原理与案例分析》</span><br><span class="line">《大型网站系统与Java中间件实践》</span><br><span class="line">Dubbo — Dubbo官方文档</span><br><span class="line">Kafka — 《Kafka权威指南》</span><br><span class="line">Zookeeper — 《从Paxos到Zookeeper 分布式一致性原理与实践》</span><br></pre></td></tr></table></figure>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre><code>MySQL — 《MySQL技术内幕 InnoDB存储引擎》
SQL — 《MySQL必知必会》、数据库SQL实战
Redis — 《Redis开发与运维》</code></pre><h2 id="网络-amp-操作系统-amp-体系结构"><a href="#网络-amp-操作系统-amp-体系结构" class="headerlink" title="网络&amp;操作系统&amp;体系结构"></a>网络&amp;操作系统&amp;体系结构</h2><pre><code>网络基础 — 《计算机网络 自顶向下方法》
HTTP — 《图解HTTP》、HTTP
《计算机操作系统》（教材）</code></pre><h2 id="数据结构-amp-算法-amp-设计模式"><a href="#数据结构-amp-算法-amp-设计模式" class="headerlink" title="数据结构&amp;算法&amp;设计模式"></a>数据结构&amp;算法&amp;设计模式</h2><pre><code>大话数据结构  
数据结构视频
设计模式 -- 《Head First设计模式》
《剑指Offer》
剑指Offer刷题66 —牛客网
leetcode在线编程</code></pre><h2 id="生产工具"><a href="#生产工具" class="headerlink" title="生产工具"></a>生产工具</h2><pre><code>Linux &amp; Shell -- Linux教程
Git -- Git远程操作详解、git - 简明指南
Maven -- Maven教程
Intellij IDEA -- IntelliJ-IDEA-Tutorial</code></pre><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><pre><code>https://github.com/halo-dev/halo
https://github.com/looly/hutool
https://github.com/sqshq/piggymetrics
https://github.com/hankcs/HanLP
https://github.com/hansonwang99</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/06/Java/" data-id="ck4doeoj60000lsk45x2904qe"
         class="article-share-link">Share</a>
      
    </footer>

  </div>

  

  

</article>



      
  </article>
  

  
</section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 Hexo</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

  <aside class="sidebar">
    
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Hexo"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>